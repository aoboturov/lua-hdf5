% FFI C example

This example illustrates how to generate C library bindings for a foreign
function interface using the script `ffi-cdecl.lua` and the Lua plugin for
GCC. The script extracts the C API of the library with the help of a C source
file containing capture macros, reads a template file, and writes an output
file with the captured C declarations.

After following the [installation] instructions, you may run the example:

~~~
make -C ffi-cdecl
~~~

An output file `C.lua` with C declarations will be created in the subdirectory.

[installation]: INSTALL.html


C capture files
---------------

To generate FFI C bindings for a library, the compiler needs to know the types,
functions, variables and constants of interest. For this purpose the C header
`ffi-cdecl.h` defines a range of [capture macros](#c-capture-macros).  These
macros are used in a C source file that includes the header(s) of the library.

As an example, consider a capture file `C.c` for the POSIX C API:

~~~ {.c}
#define _XOPEN_SOURCE 700
#include <libgen.h>
#include <sys/resource.h>
#include <time.h>
#include <unistd.h>

#include "ffi-cdecl.h"
#include "ffi-cdecl-luajit.h"

/* capture a function */
cdecl_func(getopt)
/* capture a global variable */
cdecl_var(optarg)
/* capture a type declaration */
cdecl_type(clockid_t)
/* capture a struct */
cdecl_struct(timespec)
/* capture a constant */
cdecl_const(RLIM_INFINITY)
~~~

Each capture macro receives an identifier, which may refer to a C declaration
or a preprocessor definition. The identifier is used to name the C declaration
in the output file. An output name may be overridden using the preprocessor:

~~~ {.c}
#define mygetopt getopt
cdecl_func(mygetopt)
~~~


Template files
--------------

A template file may be written in any language that supports C declarations
to describe a library interface. The template contains a keyword `@CDECL@`,
which is replaced with the captured C declarations in the output file.

The example includes a Lua template file `C.lua.in` for the [LuaJIT] compiler:

~~~ {.lua}
local ffi = require("ffi")

ffi.cdef[[
@CDECL@
]]
~~~

To avoid conflicts between C declarations imported multiple times within the
same program, for example within separate modules, it may be desirable to give
the same C declaration different names, depending on the module it is used in.

~~~ {.lua}
local ffi = require("ffi")

ffi.cdef[[
foo_@CDECL@_bar
]]
~~~

The prefix `foo_` and postfix `_bar` are included in the output name of every
captured C declaration.

[LuaJIT]: http://luajit.org/


Using the script
----------------

The script `ffi-cdecl.lua` is loaded into the GCC compiler as follows:

~~~
gcc C.c -S -fplugin=gcclua -fplugin-arg-gcclua-script=ffi-cdecl.lua
~~~

The template file and the output file are passed as plugin arguments:

~~~
gcc … -fplugin-arg-gcclua-input=C.lua.in -fplugin-arg-gcclua-output=C.lua
~~~

The generated output file `C.lua` contains the C declarations:

~~~ {.lua}
local ffi = require("ffi")

ffi.cdef[[
int getopt(int, char *const *, const char *);
extern char *optarg;
typedef int clockid_t;
struct timespec {
  long int tv_sec;
  long int tv_nsec;
};
static const int RLIM_INFINITY = -1;
]]
~~~

With a template name prefix or postfix, as explained [above](#template-files):

~~~ {.lua}
local ffi = require("ffi")

ffi.cdef[[
int foo_getopt_bar(int, char *const *, const char *) __asm__("getopt");
extern char *foo_optarg_bar __asm__("optarg");
typedef int foo_clockid_t_bar;
struct foo_timespec_bar {
  long int tv_sec;
  long int tv_nsec;
};
static const int foo_RLIM_INFINITY_bar = -1;
]]
~~~

For a complete usage example, refer to the included `Makefile`.


C capture macros
----------------

The header `ffi-cdecl.h` defines the following capture macros:

cdecl_typename(id)

  : Declares the type with the given identifier. The macro does not output
    a C declaration; it is intended to be used with types that have already
    been defined, for example in another module of a program.

    For the [FFI library of LuaJIT], built-in types may be declared as follows:

    ~~~ {.c}
    #include "ffi-cdecl-luajit.h"
    ~~~

    For the [CFFI module for Python], built-in types may be declared as follows:

    ~~~ {.c}
    #include "ffi-cdecl-python.h"
    ~~~

cdecl_type(id)

  : Defines the type with the given identifier.

    The macro outputs a C declaration of the following form:

    ~~~ {.c}
    typedef <type> <id>;
    ~~~

    If `id` is a struct, union or enum type, the members are only defined
    if the struct, union or enum is unnamed. For a named struct, union or
    enum, the members may be defined using the macro `cdecl_memb`. This
    allows for forward declarations, or declarations of incomplete types.

cdecl_memb(id)

  : Defines the members of a struct, union or enum type with the given
    identifier. The type of a member of a struct or union is recursively
    expanded; unless the type has already been defined, or the type is a
    named struct, union or enum.

    The macro outputs a C declaration of any of the following forms:

    ~~~ {.c}
    struct <id> {
      <type> <member>;
      …
    };
    ~~~

    ~~~ {.c}
    union <id> {
      <type> <member>;
      …
    };
    ~~~

    ~~~ {.c}
    enum <id> {
      <member> = <value>,
      …
    };
    ~~~

cdecl_struct(tag)

  : Defines the members of a struct with the given tag.

    The macro outputs a C declaration of of the following form:

    ~~~ {.c}
    struct <tag> {
      <type> <member>;
      …
    };
    ~~~

cdecl_union(tag)

  : Defines the members of a union with the given tag.

    The macro outputs a C declaration of of the following form:

    ~~~ {.c}
    union <tag> {
      <type> <member>;
      …
    };
    ~~~

cdecl_enum(tag)

  : Defines the members of an enumeration with the given tag.

    The macro outputs a C declaration of of the following form:

    ~~~ {.c}
    enum <tag> {
      <member> = <value>,
      …
    };
    ~~~

cdecl_func(id)

  : Declares the function with the given identifier.

    The macro outputs a C declaration of the following form:

    ~~~ {.c}
    <rtype> <id>(<argtype>, <argtype>, …);
    ~~~

    The output contains an assembler label if the symbol name differs from `id`:

    ~~~ {.c}
    <rtype> <id>(<argtype>, <argtype>, …) __asm__("<label>");
    ~~~

cdecl_var(id)

  : Declares the global variable with the given identifier.

    The macro outputs a C declaration of the following form:

    ~~~ {.c}
    <type> <id>;
    ~~~

    The output contains an assembler label if the symbol name differs from `id`:

    ~~~ {.c}
    <type> <id> __asm__("<label>");
    ~~~

cdecl_const(id)

  : Declares the function or global variable, or defines the integer constant,
    with the given identifier. Any expression containing an address-of, cast,
    or comma operator as part of the expression referred to by `id` is replaced
    by the right-most operand.

    If `id` refers to an integer constant, the macro outputs a C declaration of
    the following form:

    ~~~ {.c}
    static int <id> = <value>;
    ~~~

    Otherwise, the macro outputs a C declaration of one of the above forms.


[FFI library of LuaJIT]: http://luajit.org/ext_ffi_semantics.html#clang
[CFFI module for Python]: http://cffi.readthedocs.org/en/latest/#declaring-types-and-functions
