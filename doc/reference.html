<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Peter Colberg" />
  <title>Reference &mdash; HDF5 for Lua</title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="pandoc.css" type="text/css" />
</head>
<body>
<div class="header">
<ul>
<li><a href="index.html">HDF5 for Lua</a></li>
<li><a href="INSTALL.html">Installing</a></li>
<li><a href="README.html">User's Guide</a></li>
<li><a href="reference.html">Reference</a></li>
<li><a href="https://lists.colberg.org/listinfo/lua-hdf5">Mailing list</a></li>
<li><a href="CHANGES.html">Releases</a></li>
</ul>
</div>
<div class="body">
<h1>Reference</h1>
<div class="toc">
<ul>
<li><a href="#library">Library</a></li>
<li><a href="#files">Files</a></li>
<li><a href="#groups">Groups</a></li>
<li><a href="#datasets">Datasets</a></li>
<li><a href="#attributes">Attributes</a></li>
<li><a href="#dataspaces">Dataspaces</a></li>
<li><a href="#datatypes">Datatypes</a></li>
<li><a href="#links">Links</a></li>
<li><a href="#objects">Objects</a></li>
<li><a href="#references">References</a></li>
<li><a href="#property-lists">Property lists</a></li>
</ul>
</div>
<h2 id="library">Library</h2>
<dl>
<dt><code>hdf5.get_libversion()</code></dt>
<dd>Returns the major, minor, and release version number of the library.
</dd>
</dl>
<h2 id="files">Files</h2>
<dl>
<dt><code>hdf5.create_file(name[, flag[, fcpl[, fapl]]])</code></dt>
<dd><p>Creates a new file, and returns the file. The file is opened in read-write mode. A second, optional argument <code>flag</code> specifies whether an existing file is overwritten. A third, optional argument <code>fcpl</code> specifies the <a href="#file-creation-properties">file creation properties</a>. A fourth, optional argument <code>fapl</code> specifies the <a href="#file-access-properties">file access properties</a>.</p>
<p><code>flag</code> can be any of the following:</p>
<ul>
<li><strong>&quot;trunc&quot;</strong>: an existing file is overwritten (the default);</li>
<li><strong>&quot;excl&quot;</strong>: an existing file is not overwritten, and this function raises an error.</li>
</ul>
</dd>
<dt><code>hdf5.open_file(name[, flag[, fapl]])</code></dt>
<dd><p>Opens an existing file, and returns the file. A second, optional argument <code>flag</code> specifies the mode in which the file is opened. A third, optional argument <code>fapl</code> specifies the <a href="#file-access-properties">file access properties</a>.</p>
<p><code>flag</code> can be any of the following:</p>
<ul>
<li><strong>&quot;rdonly&quot;</strong>: read-only mode (the default);</li>
<li><strong>&quot;rdwr&quot;</strong>: read-write mode.</li>
</ul>
</dd>
<dt><code>hdf5.is_hdf5(name)</code></dt>
<dd><p>Returns <strong>true</strong> if the file with the given name is an HDF5 file, otherwise returns <strong>false</strong>.</p>
</dd>
<dt><code>file:get_file_create_plist()</code></dt>
<dd><p>Returns the <a href="#file-creation-properties">file creation properties</a> with which the file was created.</p>
</dd>
<dt><code>file:get_file_access_plist()</code></dt>
<dd><p>Returns the <a href="#file-access-properties">file access properties</a> with which the file was opened.</p>
</dd>
<dt><code>file:get_name()</code></dt>
<dd><p>Returns the filename.</p>
</dd>
<dt><code>file:get_intent()</code></dt>
<dd><p>Returns the mode in which the file was opened.</p>
</dd>
<dt><code>file:flush()</code></dt>
<dd><p>Flushes file contents to disk.</p>
</dd>
<dt><code>file:close()</code></dt>
<dd><p>Closes the file and all open objects that reference the file. This function need only be called if a file should be immediately closed; otherwise, the file will be closed when all objects that reference the file have been garbage collected eventually.</p>
</dd>
</dl>
<h2 id="groups">Groups</h2>
<dl>
<dt><code>group:create_group(name[, lcpl[, gcpl[, gapl]]])</code></dt>
<dd><p>Creates and returns a group that is linked into the file at the given location with the given name. <code>group</code> may be a group or file. A second, optional argument <code>lcpl</code> specifies the <a href="#link-creation-properties">link creation properties</a>. A third, optional argument <code>gcpl</code> specifies the group creation properties. A fourth, optional argument <code>gapl</code> specifies the group access properties.</p>
</dd>
<dt><code>group:create_anon_group([gcpl[, gapl]])</code></dt>
<dd><p>Creates and returns a group in the file that contains the given location. The group must be <a href="#objects">linked</a> into the file separately, otherwise it is deleted when the file is closed. <code>group</code> may be a group or file. A first, optional argument <code>gcpl</code> specifies the group creation properties. A second, optional argument <code>gapl</code> specifies the group specifies the group access properties.</p>
</dd>
<dt><code>group:open_group(name[, gapl])</code></dt>
<dd><p>Opens and returns the group at the given location with the given name. <code>group</code> may be a group or file. A second, optional argument <code>gapl</code> specifies the group access properties.</p>
</dd>
</dl>
<h2 id="datasets">Datasets</h2>
<dl>
<dt><code>group:create_dataset(name, dtype, space[, lcpl[, dcpl[, dapl]]])</code></dt>
<dd><p>Creates and returns a dataset of the given datatype and dataspace that is linked into the file at the given location with the given name. <code>group</code> may be a group or file. A fourth, optional argument <code>lcpl</code> specifies the <a href="#link-creation-properties">link creation properties</a>. A fifth, optional argument <code>dcpl</code> specifies the <a href="#dataset-creation-properties">dataset creation properties</a>. A sixth, optional argument <code>dapl</code> specifies the dataset access properties.</p>
</dd>
<dt><code>group:create_anon_dataset(dtype, space[, dcpl[, dapl]])</code></dt>
<dd><p>Creates and returns dataset of the given datatype and dataspace in the file that contains the given location. The dataset must be <a href="#objects">linked</a> into the file separately, otherwise it is deleted when the file is closed. <code>group</code> may be a group or file. A third, optional argument <code>dcpl</code> specifies the <a href="#dataset-creation-properties">dataset creation properties</a>. A fourth, optional argument <code>dapl</code> specifies the dataset access properties.</p>
</dd>
<dt><code>group:open_dataset(name[, dapl])</code></dt>
<dd><p>Opens and returns the dataset at the given location with the given name. <code>group</code> may be a group or file. A second, optional argument <code>dapl</code> specifies the dataset access properties.</p>
</dd>
<dt><code>dataset:get_dataset_create_plist()</code></dt>
<dd><p>Returns the <a href="#dataset-creation-properties">dataset creation properties</a> with which the dataset was created.</p>
</dd>
<dt><code>dataset:get_dataset_access_plist()</code></dt>
<dd><p>Returns the dataset access properties with which the dataset was opened.</p>
<p><em>This function is available with HDF5 1.8.3 or later.</em></p>
</dd>
<dt><code>dataset:get_type()</code></dt>
<dd><p>Returns the datatype of the dataset.</p>
</dd>
<dt><code>dataset:get_space()</code></dt>
<dd><p>Returns the dataspace of the dataset.</p>
</dd>
<dt><code>dataset:set_extent(dims)</code></dt>
<dd><p>Changes the dimensions of the dataspace of the dataset. <code>dims</code> is a table with a sequence that specifies for each dimension the new size of the dataspace, which must be smaller than or equal to the corresponding maximum size of the dataspace specified upon creation of the dataset.</p>
</dd>
<dt><code>dataset:write(buf, mem_type[, mem_space[, file_space[, dxpl]]])</code></dt>
<dd><p>Writes data from the given buffer to the dataset. <code>buf</code> specifies a C array object. <code>mem_type</code> is a datatype that corresponds to the C type of the buffer; it must be <a href="http://www.hdfgroup.org/HDF5/doc/UG/11_Datatypes.html#Dtransfer">convertible</a> to the datatype of the dataset. A third, optional argument <code>mem_space</code> specifies a dataspace that describes the elements to read from within the buffer. A fourth, optional argument <code>file_space</code> specifies a dataspace that describes the elements to write to within the dataset. A fifth, optional argument <code>dxpl</code> specifies the <a href="#dataset-transfer-properties">dataset transfer properties</a>.</p>
<p>The given memory and file dataspaces must be <a href="http://www.hdfgroup.org/HDF5/doc/UG/12_Dataspaces.html#Dtransfer">compatible</a>. If <code>mem_space</code> is not specified, the memory dataspace defaults to the file dataspace. If <code>file_space</code> is not specified, the file dataspace defaults to the dataspace of the dataset.</p>
</dd>
<dt><code>dataset:read(buf, mem_type[, mem_space[, file_space[, dxpl]]])</code></dt>
<dd><p>Reads data from the given buffer to the dataset. <code>buf</code> specifies a C array object. <code>mem_type</code> is a datatype that corresponds to the C type of the buffer; it must be <a href="http://www.hdfgroup.org/HDF5/doc/UG/11_Datatypes.html#Dtransfer">convertible</a> to the datatype of the dataset. A third, optional argument <code>mem_space</code> specifies a dataspace that describes the elements to write to within the buffer. A fourth, optional argument <code>file_space</code> specifies a dataspace that describes the elements to read from within the dataset. A fifth, optional argument <code>dxpl</code> specifies the <a href="#dataset-transfer-properties">dataset transfer properties</a>.</p>
<p>The given memory and file dataspaces must be <a href="http://www.hdfgroup.org/HDF5/doc/UG/12_Dataspaces.html#Dtransfer">compatible</a>. If <code>mem_space</code> is not specified, the memory dataspace defaults to the file dataspace. If <code>file_space</code> is not specified, the file dataspace defaults to the dataspace of the dataset.</p>
</dd>
<dt><code>hdf5.vlen_reclaim(buf, mem_type, mem_space[, dxpl])</code></dt>
<dd><p>Free the memory allocated when reading a dataset or an attribute of variable-length datatype. <code>buf</code> is the buffer specified when the dataset or attribute was read. <code>mem_type</code> is the datatype specified when the dataset or attribute was read. <code>mem_space</code> is the memory dataspace specified when the dataset was read; or, if a memory dataspace was not specified, the file dataspace specified when the dataset was read; otherwise the dataspace of the dataset or attribute. <code>dxpl</code> is the <a href="#dataset-transfer-properties">dataset transfer properties</a> specified when the dataset was read.</p>
</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><code>loc:create_attribute(name, dtype, space[, acpl[, aapl]])</code></dt>
<dd><p>Creates and returns an attribute at the given location of the given name, datatype and dataspace. <code>loc</code> may be a dataset, a committed datatype, a group, or a file. A fourth, optional argument <code>acpl</code> specifies the attribute creation properties. A fifth, optional argument <code>aapl</code> specifies the attribute access properties.</p>
</dd>
<dt><code>loc:open_attribute(name[, aapl])</code></dt>
<dd><p>Opens and returns an existing attribute at the given location with the given name. <code>loc</code> may be a dataset, a committed datatype, a group, or a file. A second, optional argument <code>aapl</code> specifies the attribute access properties.</p>
</dd>
<dt><code>loc:exists_attribute(name)</code></dt>
<dd><p>Returns <strong>true</strong> if an attribute with the given name exists; otherwise returns <strong>false</strong>.</p>
</dd>
<dt><code>loc:rename_attribute(old_name, new_name)</code></dt>
<dd><p>Renames the attribute with the name <code>old_name</code> to <code>new_name</code>.</p>
</dd>
<dt><code>loc:delete_attribute(name)</code></dt>
<dd><p>Deletes the attribute with the given name.</p>
</dd>
<dt><code>attr:get_name()</code></dt>
<dd><p>Returns the name of the attribute.</p>
</dd>
<dt><code>attr:get_type()</code></dt>
<dd><p>Returns the datatype of the attribute.</p>
</dd>
<dt><code>attr:get_space()</code></dt>
<dd><p>Returns the dataspace of the attribute.</p>
</dd>
<dt><code>attr:write(buf, mem_type)</code></dt>
<dd><p>Writes data from the given buffer to the attribute. <code>buf</code> specifies a C array object. <code>mem_type</code> is a datatype that corresponds to the C type of the buffer; it must be <a href="http://www.hdfgroup.org/HDF5/doc/UG/11_Datatypes.html#Dtransfer">convertible</a> to the datatype of the attribute.</p>
</dd>
<dt><code>attr:read(buf, mem_type)</code></dt>
<dd><p>Reads data from the given buffer to the attribute. <code>buf</code> specifies a C array object. <code>mem_type</code> is a datatype that corresponds to the C type of the buffer; it must be <a href="http://www.hdfgroup.org/HDF5/doc/UG/11_Datatypes.html#Dtransfer">convertible</a> to the datatype of the attribute.</p>
</dd>
</dl>
<h2 id="dataspaces">Dataspaces</h2>
<dl>
<dt><code>hdf5.create_space(class)</code></dt>
<dd><p>Creates and returns a dataspace of the given class.</p>
<p><code>class</code> can be any of the following:</p>
<ul>
<li><strong>&quot;scalar&quot;</strong>: a dataspace of a single element;</li>
<li><strong>&quot;simple&quot;</strong>: a dataspace of a (multi-dimensional) array of elements;</li>
<li><strong>&quot;null&quot;</strong>: a dataspace that has no elements.</li>
</ul>
</dd>
<dt><code>space:get_simple_extent_type()</code></dt>
<dd><p>Returns the class of the dataspace.</p>
</dd>
<dt><code>hdf5.create_simple_space(dims[, maxdims])</code></dt>
<dd><p>Creates and returns a dataspace of the given current and maximum dimensions. <code>dims</code> is a table with a sequence that specifies the current dimensions of the dataspace; each element is a number that specifies the size of a dimension. The optional argument <code>maxdims</code> is a table that specifies the maximum dimensions of the dataspace; each element is either a number equal to or greater than the corresponding element of <code>dims</code>, or <strong>nil</strong> to specify that a dimension is of unlimited maximum size.</p>
</dd>
<dt><code>space:set_extent_simple(dims[, maxdims])</code></dt>
<dd><p>Sets the current and maximum dimensions of the dataspace.</p>
</dd>
<dt><code>space:get_simple_extent_dims()</code></dt>
<dd><p>Returns two tables that specify the current and maximum dimensions of the dataspace. For each dimension of unlimited maximum size, the corresponding element of the second table is <strong>nil</strong>.</p>
</dd>
<dt><code>space:extent_equal(space2)</code></dt>
<dd><p>Returns <strong>true</strong> if the dataspace extents of the given dataspaces are equal, otherwise returns <strong>false</strong>.</p>
</dd>
<dt><code>space:select_hyperslab(op, start, stride, count, block)</code></dt>
<dd><p>Selects a hyperslab region of the dataspace. <code>op</code> specifies how the new selection is merged with an existing selection of the dataspace. <code>op</code> can be any of the following, to select elements that are</p>
<ul>
<li><strong>&quot;set&quot;</strong>: in the new selection;</li>
<li><strong>&quot;or&quot;</strong>: in the existing selection or in the new selection;</li>
<li><strong>&quot;and&quot;</strong>: both in the existing selection and in the new selection;</li>
<li><strong>&quot;xor&quot;</strong>: in the existing selection or in the new selection, but not in both selections;</li>
<li><strong>&quot;notb&quot;</strong>: in the existing selection, but not in the new selection;</li>
<li><strong>&quot;nota&quot;</strong>: in the new selection, but not in the existing selection;</li>
</ul>
<p>A hyperslab region consists of disjoint blocks of elements. <code>start</code> is a table with a sequence that specifies for each dimension the non-negative offset of the first element of the first block relative to the origin of the region. <code>stride</code> is either a table with a sequence that specifies for each dimension the positive offset of the first element of a block relative to the first element of the previous block; or <strong>nil</strong>, which is equivalent to an offset of 1 for each dimension. <code>count</code> is a table with a sequence that specifies for each dimension the number of blocks. <code>block</code> is either a table with a sequence that specifies for each dimension the size of a block; or <strong>nil</strong>, which is equivalent to a size of 1 for each dimension.</p>
</dd>
<dt><code>space:select_valid()</code></dt>
<dd><p>Returns <strong>true</strong> if the selection of the dataspace lies within the current dimensions of the dataspace, otherwise returns <strong>false</strong>.</p>
</dd>
<dt><code>space:offset_simple(offset)</code></dt>
<dd><p>Sets the offset of the selection of the dataspace. <code>offset</code> is a table with a sequence that specifies for each dimension the offset of the origin of the selected region relative to the origin of the dataspace.</p>
</dd>
</dl>
<h2 id="datatypes">Datatypes</h2>
<dl>
<dt><code>dtype:commit(group, name[, lcpl[, tcpl[, tapl]]])</code></dt>
<dd><p>Commit a transient datatype, and link the datatype into into the given group with the given name. A transient datatype is a datatype that is not locked and not committed. A third, optional argument <code>lcpl</code> specifies the <a href="#link-creation-properties">link creation properties</a>. A fourth, optional argument <code>tcpl</code> specifies the datatype creation properties. A fourth, optional argument <code>tapl</code> specifies the datatype access properties.</p>
</dd>
<dt><code>dtype:commit_anon(group[, tcpl[, tapl]])</code></dt>
<dd><p>Commit a transient datatype to the file that contains the given group. The datatype must be <a href="#objects">linked</a> into the file separately, otherwise it is deleted when the file is closed.</p>
</dd>
<dt><code>dtype:committed()</code></dt>
<dd><p>Returns <strong>true</strong> if the datatype has been committed; otherwise returns <strong>false</strong>.</p>
</dd>
<dt><code>dtype:copy()</code></dt>
<dd><p>Creates and returns a copy of the datatype.</p>
</dd>
<dt><code>dtype:equal(dtype2)</code></dt>
<dd><p>Returns <strong>true</strong> if the given datatypes are equal, otherwise returns <strong>false</strong>.</p>
</dd>
<dt><code>dtype:get_class()</code></dt>
<dd><p>Returns the class of the datatype, which is one of the following:</p>
<ul>
<li><strong>&quot;integer&quot;</strong>: integer datatype;</li>
<li><strong>&quot;float&quot;</strong>: floating-point datatype;</li>
<li><strong>&quot;string&quot;</strong>: fixed-length or variable-length string datatype;</li>
<li><strong>&quot;bitfield&quot;</strong>: bit field datatype;</li>
<li><strong>&quot;opaque&quot;</strong>: opaque datatype;</li>
<li><strong>&quot;compound&quot;</strong>: compound datatype;</li>
<li><strong>&quot;reference&quot;</strong>: object or dataset region reference datatype;</li>
<li><strong>&quot;enum&quot;</strong>: enumeration datatype;</li>
<li><strong>&quot;vlen&quot;</strong>: variable-length datatype;</li>
<li><strong>&quot;array&quot;</strong>: array datatype.</li>
</ul>
</dd>
<dt><code>dtype:get_size()</code></dt>
<dd><p>Returns the size in bytes of the datatype. If <code>dtype</code> is a variable-length datatype, returns the size of a pointer to an element of that datatype.</p>
</dd>
</dl>
<h3 id="atomic-datatypes">Atomic datatypes</h3>
<dl>
<dt><code>dtype:set_size(size)</code></dt>
<dd><p>Sets the size in bytes of the datatype. If <code>dtype</code> is a string datatype, <code>size</code> may be specified as <strong>&quot;variable&quot;</strong> to create a variable-length datatype.</p>
</dd>
<dt><code>dtype:set_cset(cset)</code></dt>
<dd><p>Sets the character encoding of a string datatype, which may be any of the following:</p>
<ul>
<li><strong>&quot;ascii&quot;</strong>: ASCII character encoding (the default);</li>
<li><strong>&quot;utf8&quot;</strong>: UTF-8 character encoding of the Unicode character set.</li>
</ul>
</dd>
<dt><code>dtype:get_cset()</code></dt>
<dd><p>Returns the character encoding of a string datatype.</p>
</dd>
</dl>
<h3 id="variable-length-datatypes">Variable-length datatypes</h3>
<dl>
<dt><code>dtype:is_variable_str()</code></dt>
<dd>Returns <strong>true</strong> if the datatype is a variable-length string datatype, otherwise returns <strong>false</strong>.
</dd>
</dl>
<h3 id="enumeration-datatypes">Enumeration datatypes</h3>
<dl>
<dt><code>dtype:enum_create()</code></dt>
<dd><p>Creates and returns an enumeration datatype of base datatype <code>dtype</code>.</p>
</dd>
<dt><code>dtype:enum_insert(name, value)</code></dt>
<dd><p>Inserts a member with the given name and value into an enumeration datatype. <code>value</code> is a C array object of a C type that corresponds to the base datatype of the enumeration datatype.</p>
</dd>
<dt><code>dtype:enum_nameof(value)</code></dt>
<dd><p>Returns the name corresponding to a value of an enumeration datatype. <code>value</code> is a C array object of a C type that corresponds to the base datatype of the enumeration datatype.</p>
</dd>
<dt><code>dtype:enum_valueof(name, value)</code></dt>
<dd><p>Retrieves the value corresponding to a name of an enumeration datatype. <code>value</code> is a C array object of a C type that corresponds to the base datatype of the enumeration datatype.</p>
</dd>
</dl>
<h3 id="predefined-datatypes">Predefined datatypes</h3>
<p>The library defines the following atomic datatypes.</p>
<h4 id="integer-datatypes">Integer datatypes</h4>
<table>
<col width="50%" />
<col width="50%" />
<tbody>
<tr class="odd">
<td align="left"><dl>
<dt><code>hdf5.char</code></dt>
<dd>C type <code>char</code>
</dd>
<dt><code>hdf5.schar</code></dt>
<dd>C type <code>signed char</code>
</dd>
<dt><code>hdf5.short</code></dt>
<dd>C type <code>short</code>
</dd>
<dt><code>hdf5.int</code></dt>
<dd>C type <code>int</code>
</dd>
<dt><code>hdf5.long</code></dt>
<dd>C type <code>long</code>
</dd>
<dt><code>hdf5.llong</code></dt>
<dd>C type <code>long long</code>
</dd>
</dl></td>
<td align="left"><dl>
<dt><code>hdf5.opaque</code></dt>
<dd>Opaque byte string
</dd>
<dt><code>hdf5.uchar</code></dt>
<dd>C type <code>unsigned char</code>
</dd>
<dt><code>hdf5.ushort</code></dt>
<dd>C type <code>unsigned short</code>
</dd>
<dt><code>hdf5.uint</code></dt>
<dd>C type <code>unsigned int</code>
</dd>
<dt><code>hdf5.ulong</code></dt>
<dd>C type <code>unsigned long</code>
</dd>
<dt><code>hdf5.ullong</code></dt>
<dd>C type <code>unsigned long long</code>
</dd>
</dl></td>
</tr>
</tbody>
</table>
<table>
<col width="50%" />
<col width="50%" />
<tbody>
<tr class="odd">
<td align="left"><dl>
<dt><code>hdf5.int8</code></dt>
<dd>C type <code>int8_t</code>
</dd>
<dt><code>hdf5.int16</code></dt>
<dd>C type <code>int16_t</code>
</dd>
<dt><code>hdf5.int32</code></dt>
<dd>C type <code>int32_t</code>
</dd>
<dt><code>hdf5.int64</code></dt>
<dd>C type <code>int64_t</code>
</dd>
</dl></td>
<td align="left"><dl>
<dt><code>hdf5.uint8</code></dt>
<dd>C type <code>uint8_t</code>
</dd>
<dt><code>hdf5.uint16</code></dt>
<dd>C type <code>uint16_t</code>
</dd>
<dt><code>hdf5.uint32</code></dt>
<dd>C type <code>uint32_t</code>
</dd>
<dt><code>hdf5.uint64</code></dt>
<dd>C type <code>uint64_t</code>
</dd>
</dl></td>
</tr>
</tbody>
</table>
<table>
<col width="50%" />
<col width="50%" />
<tbody>
<tr class="odd">
<td align="left"><dl>
<dt><code>hdf5.i8be</code></dt>
<dd>Signed 8 bit big-endian
</dd>
<dt><code>hdf5.i8le</code></dt>
<dd>Signed 8 bit little-endian
</dd>
<dt><code>hdf5.i16be</code></dt>
<dd>Signed 16 bit big-endian
</dd>
<dt><code>hdf5.i16le</code></dt>
<dd>Signed 16 bit little-endian
</dd>
<dt><code>hdf5.i32be</code></dt>
<dd>Signed 32 bit big-endian
</dd>
<dt><code>hdf5.i32le</code></dt>
<dd>Signed 32 bit little-endian
</dd>
<dt><code>hdf5.i64be</code></dt>
<dd>Signed 64 bit big-endian
</dd>
<dt><code>hdf5.i64le</code></dt>
<dd>Signed 64 bit little-endian
</dd>
</dl></td>
<td align="left"><dl>
<dt><code>hdf5.u8be</code></dt>
<dd>Unsigned 8 bit big-endian
</dd>
<dt><code>hdf5.u8le</code></dt>
<dd>Unsigned 8 bit little-endian
</dd>
<dt><code>hdf5.u16be</code></dt>
<dd>Unsigned 16 bit big-endian
</dd>
<dt><code>hdf5.u16le</code></dt>
<dd>Unsigned 16 bit little-endian
</dd>
<dt><code>hdf5.u32be</code></dt>
<dd>Unsigned 32 bit big-endian
</dd>
<dt><code>hdf5.u32le</code></dt>
<dd>Unsigned 32 bit little-endian
</dd>
<dt><code>hdf5.u64be</code></dt>
<dd>Unsigned 64 bit big-endian
</dd>
<dt><code>hdf5.u64le</code></dt>
<dd>Unsigned 64 bit little-endian
</dd>
</dl></td>
</tr>
</tbody>
</table>
<h4 id="bit-field-datatypes">Bit field datatypes</h4>
<table>
<col width="50%" />
<col width="50%" />
<tbody>
<tr class="odd">
<td align="left"><dl>
<dt><code>hdf5.b8</code></dt>
<dd>1 byte bit field
</dd>
<dt><code>hdf5.b32</code></dt>
<dd>4 byte bit field
</dd>
</dl></td>
<td align="left"><dl>
<dt><code>hdf5.b16</code></dt>
<dd>2 byte bit field
</dd>
<dt><code>hdf5.b64</code></dt>
<dd>8 byte bit field
</dd>
</dl></td>
</tr>
</tbody>
</table>
<table>
<col width="50%" />
<col width="50%" />
<tbody>
<tr class="odd">
<td align="left"><dl>
<dt><code>hdf5.b8be</code></dt>
<dd>8 bit big-endian
</dd>
<dt><code>hdf5.b16be</code></dt>
<dd>16 bit big-endian
</dd>
<dt><code>hdf5.b32be</code></dt>
<dd>32 bit big-endian
</dd>
<dt><code>hdf5.b64be</code></dt>
<dd>64 bit big-endian
</dd>
</dl></td>
<td align="left"><dl>
<dt><code>hdf5.b8le</code></dt>
<dd>8 bit little-endian
</dd>
<dt><code>hdf5.b16le</code></dt>
<dd>16 bit little-endian
</dd>
<dt><code>hdf5.b32le</code></dt>
<dd>32 bit little-endian
</dd>
<dt><code>hdf5.b64le</code></dt>
<dd>64 bit little-endian
</dd>
</dl></td>
</tr>
</tbody>
</table>
<h4 id="floating-point-datatypes">Floating-point datatypes</h4>
<table>
<col width="50%" />
<col width="50%" />
<tbody>
<tr class="odd">
<td align="left"><dl>
<dt><code>hdf5.float</code></dt>
<dd>C type <code>float</code>
</dd>
</dl></td>
<td align="left"><dl>
<dt><code>hdf5.double</code></dt>
<dd>C type <code>double</code>
</dd>
</dl></td>
</tr>
</tbody>
</table>
<table>
<col width="50%" />
<col width="50%" />
<tbody>
<tr class="odd">
<td align="left"><dl>
<dt><code>hdf5.f32be</code></dt>
<dd>32 bit big-endian
</dd>
<dt><code>hdf5.f64be</code></dt>
<dd>64 bit big-endian
</dd>
</dl></td>
<td align="left"><dl>
<dt><code>hdf5.f32le</code></dt>
<dd>32 bit little-endian
</dd>
<dt><code>hdf5.f64le</code></dt>
<dd>64 bit little-endian
</dd>
</dl></td>
</tr>
</tbody>
</table>
<h4 id="reference-datatypes">Reference datatypes</h4>
<table>
<col width="50%" />
<col width="50%" />
<tbody>
<tr class="odd">
<td align="left"><dl>
<dt><code>hdf5.ref_obj</code></dt>
<dd>HDF5 object reference
</dd>
</dl></td>
<td align="left"><dl>
<dt><code>hdf5.ref_dsetreg</code></dt>
<dd>HDF5 dataset region reference
</dd>
</dl></td>
</tr>
</tbody>
</table>
<h4 id="string-datatypes">String datatypes</h4>
<table>
<col width="50%" />
<col width="50%" />
<tbody>
<tr class="odd">
<td align="left"><dl>
<dt><code>hdf5.c_s1</code></dt>
<dd>C string
</dd>
</dl></td>
<td align="left"><dl>
<dt><code>hdf5.fortran_s1</code></dt>
<dd>Fortran string
</dd>
</dl></td>
</tr>
</tbody>
</table>
<h2 id="links">Links</h2>
<dl>
<dt><code>group:create_hard_link(obj_group, obj_name, link_name[, lcpl[, lapl]])</code></dt>
<dd><p>Creates a hard link with the given name to the object at the given location with the given name. If the location of the hard link and the location of the object are the same, <code>obj_group</code> may be specified as <strong>nil</strong>. A fourth, optional argument <code>lcpl</code> specifies the <a href="#link-creation-properties">link creation properties</a>. A fifth, optional argument <code>lapl</code> specifies the link access properties.</p>
</dd>
<dt><code>group:create_soft_link(target_path, link_name[, lcpl[, lapl]])</code></dt>
<dd><p>Creates a soft link with the given name and target path. <code>target_path</code> may be an absolute path within the file, or a path relative to the path of the group. A third, optional argument <code>lcpl</code> specifies the <a href="#link-creation-properties">link creation properties</a>. A fourth, optional argument <code>lapl</code> specifies the link access properties.</p>
</dd>
<dt><code>group:exists_link(name[, lapl])</code></dt>
<dd><p>Returns <strong>true</strong> if a link with the given name exists, otherwise returns <strong>false</strong>. A second, optional argument <code>lapl</code> specifies the link access properties.</p>
</dd>
<dt><code>group:delete_link(name[, lapl])</code></dt>
<dd><p>Deletes the link with the given name. A second, optional argument <code>lapl</code> specifies the link access properties.</p>
</dd>
</dl>
<h2 id="objects">Objects</h2>
<dl>
<dt><code>group:open_object(name[, lapl])</code></dt>
<dd><p>Opens and returns the object with the given name, which may be a group, a dataset, or a committed datatype. <code>group</code> may be a group or file. A second, optional argument <code>lapl</code> specifies the link access properties.</p>
</dd>
<dt><code>group:exists_object(name[, lapl])</code></dt>
<dd><p>Returns <strong>true</strong> if an object with the given name exists, otherwise returns <strong>false</strong>. <code>group</code> may be a group or file. A second, optional argument <code>lapl</code> specifies the link access properties.</p>
<p><em>This function is available with HDF5 1.8.5 or later.</em></p>
</dd>
<dt><code>group:link_object(obj, link_name[, lcpl[, lapl]])</code></dt>
<dd><p>Links the given object into the file at the given location with the given name. <code>group</code> may be a group or file. A third, optional argument <code>lcpl</code> specifies the <a href="#link-creation-properties">link creation properties</a>. A fourth, optional argument <code>lapl</code> specifies the link access properties.</p>
</dd>
<dt><code>object:get_object_type()</code></dt>
<dd><p>Returns the type of the given object, which is one of the following:</p>
<ul>
<li><strong>&quot;file&quot;</strong>: a file;</li>
<li><strong>&quot;group&quot;</strong>: a group;</li>
<li><strong>&quot;dataset&quot;</strong>: a dataset;</li>
<li><strong>&quot;datatype&quot;</strong>: a datatype;</li>
<li><strong>&quot;attr&quot;</strong>: an attribute.</li>
</ul>
</dd>
<dt><code>object:get_object_name()</code></dt>
<dd><p>Returns an absolute path within the file to the given object, which may be a file, a group, a dataset, a committed datatype, or an attribute. If multiple paths to the object exist, the function returns any one of these paths. If the object is an attribute, the function returns a path to the object to which the attribute is attached.</p>
</dd>
<dt><code>object:get_object_info()</code></dt>
<dd><p>Returns a value with the following methods:</p>
<dl>
<dt><code>info:get_atime()</code></dt>
<dd>Returns the last time the object was read or written.
</dd>
<dt><code>info:get_mtime()</code></dt>
<dd>Returns the last time the raw data in the object was changed.
</dd>
<dt><code>info:get_ctime()</code></dt>
<dd>Returns the last time the metadata for the object was changed.
</dd>
<dt><code>info:get_btime()</code></dt>
<dd>Returns the time the object was created.
</dd>
<dt><code>info:get_num_links()</code></dt>
<dd>Returns the number of links to the object.
</dd>
<dt><code>info:get_num_attrs()</code></dt>
<dd>Returns the number of attributes.
</dd>
<dt><code>info:get_type()</code></dt>
<dd><p>Returns the type of the object, which can be any of the following:</p>
<ul>
<li><strong>&quot;group&quot;</strong>: a group;</li>
<li><strong>&quot;dataset&quot;</strong>: a dataset;</li>
<li><strong>&quot;named_datatype&quot;</strong>: a committed datatype.</li>
</ul>
</dd>
</dl>
</dd>
</dl>
<h2 id="references">References</h2>
<dl>
<dt><code>loc:create_reference(name, ref, ref_type, space)</code></dt>
<dd><p>Creates a reference to the object or dataset region at the given location with the given name. <code>loc</code> may be a dataset, a committed datatype, a group, or a file.</p>
<p><code>ref_type</code> can be any of the following, to create a</p>
<ul>
<li><strong>&quot;object&quot;</strong>: object reference;</li>
<li><strong>&quot;dataset_region&quot;</strong>: dataset region reference.</li>
</ul>
</dd>
<dt><code>object:dereference(ref, ref_type)</code></dt>
<dd><p>Opens and returns the object referenced by the given reference of the given reference type. <code>object</code> may be any group, dataset, committed datatype or attribute within a file, or a file.</p>
</dd>
<dt><code>object:get_reference_name(ref, ref_type)</code></dt>
<dd><p>Returns the path of the object referenced by the given reference of the given reference type. <code>object</code> may be any group, dataset, committed datatype or attribute within a file, or a file. If the referenced object is linked into the file at multiple paths, the function returns any one of the paths.</p>
</dd>
<dt><code>object:get_reference_type(ref, ref_type)</code></dt>
<dd><p>Returns the type of the object referenced by the given reference of the given reference type. <code>object</code> may be any group, dataset, committed datatype or attribute within a file, or a file.</p>
<p>The object type is one of the following:</p>
<ul>
<li><strong>&quot;group&quot;</strong>,</li>
<li><strong>&quot;dataset&quot;</strong>,</li>
<li><strong>&quot;named_datatype&quot;</strong>.</li>
</ul>
</dd>
<dt><code>object:get_reference_region(ref, ref_type)</code></dt>
<dd><p>Returns the dataspace with the selection referenced by the given dataset region reference. <code>ref_type</code> must be equal to <strong>&quot;dataset_region&quot;</strong>.</p>
</dd>
</dl>
<h2 id="property-lists">Property lists</h2>
<dl>
<dt><code>hdf5.create_plist(class)</code></dt>
<dd><p>Creates and returns a property list of the given class.</p>
<p><code>class</code> can be any of the following:</p>
<ul>
<li><strong>&quot;file_create&quot;</strong>: <a href="#file-creation-properties">file creation properties</a>;</li>
<li><strong>&quot;file_access&quot;</strong>: <a href="#file-access-properties">file access properties</a>;</li>
<li><strong>&quot;group_create&quot;</strong>: group creation properties;</li>
<li><strong>&quot;group_access&quot;</strong>: group access properties;</li>
<li><strong>&quot;dataset_create&quot;</strong>: <a href="#dataset-creation-properties">dataset creation properties</a>;</li>
<li><strong>&quot;dataset_access&quot;</strong>: dataset access properties;</li>
<li><strong>&quot;dataset_xfer&quot;</strong>: <a href="#dataset-transfer-properties">dataset transfer properties</a>;</li>
<li><strong>&quot;attribute_create&quot;</strong>: attribute creation properties;</li>
<li><strong>&quot;datatype_create&quot;</strong>: datatype creation properties;</li>
<li><strong>&quot;datatype_access&quot;</strong>: datatype access properties;</li>
<li><strong>&quot;object_copy&quot;</strong>: object copying properties;</li>
<li><strong>&quot;link_create&quot;</strong>: <a href="#link-creation-properties">link creation properties</a>;</li>
<li><strong>&quot;link_access&quot;</strong>: link access properties.</li>
</ul>
</dd>
</dl>
<h3 id="file-creation-properties">File creation properties</h3>
<dl>
<dt><code>fcpl:get_version()</code></dt>
<dd><p>Returns version information about the file.</p>
<p>This function returns the following values:</p>
<ul>
<li>the super block version number;</li>
<li>the global freelist version number;</li>
<li>the symbol table version number;</li>
<li>the shared object header version number.</li>
</ul>
</dd>
</dl>
<h3 id="file-access-properties">File access properties</h3>
<dl>
<dt><code>fapl:set_libver_bounds(low, high)</code></dt>
<dd><p>Sets the lower and the upper bound on the file format version to be used when creating the file itself, or objects in the file. A function creating an object will use the earliest possible file format version not earlier than the version specified by <code>low</code>. If this version is later than the version specified by <code>high</code>, the function will fail to create the object and raise an error.</p>
<p><code>low</code> can be any of the following:</p>
<ul>
<li><strong>&quot;earliest&quot;</strong>: the earliest file format version;</li>
<li><strong>&quot;18&quot;</strong>: the file format version corresponding to version 1.8 of the library (the default);</li>
<li><strong>&quot;latest&quot;</strong>: the latest file format version.</li>
</ul>
<p><code>high</code> can be any of the following:</p>
<ul>
<li><strong>&quot;18&quot;</strong>: the file format version corresponding to version 1.8 of the library;</li>
<li><strong>&quot;latest&quot;</strong>: the latest file format version (the default).</li>
</ul>
</dd>
<dt><code>fapl:get_libver_bounds()</code></dt>
<dd><p>Returns the lower and the upper bound on the file format version.</p>
</dd>
</dl>
<p><em>The following methods are available if HDF5 is compiled with MPI-IO support.</em></p>
<dl>
<dt><code>fapl:set_fapl_mpio(comm[, info])</code></dt>
<dd>Store MPI communicator and info object.
</dd>
</dl>
<h3 id="dataset-creation-properties">Dataset creation properties</h3>
<dl>
<dt><code>dcpl:set_layout(layout)</code></dt>
<dd><p>Set the <a href="http://www.hdfgroup.org/HDF5/doc/UG/10_Datasets.html#Allocation">storage layout</a> of the raw data of a dataset, which can be any of the following:</p>
<ul>
<li>&quot;<strong>contiguous</strong>&quot;: the raw data is stored in a contiguous chunk (the default);</li>
<li>&quot;<strong>chunked</strong>&quot;: the raw data is in multiple, separate chunks;</li>
<li>&quot;<strong>compact</strong>&quot;: the raw data is stored in the dataset object header.</li>
</ul>
</dd>
<dt><code>dcpl:get_layout()</code></dt>
<dd><p>Returns the storage layout of the raw data of a dataset.</p>
</dd>
<dt><code>dcpl.set_chunk(dims)</code></dt>
<dd><p>Set a chunked storage layout for a dataset, and sets the size of a chunk. <code>dims</code> is a table with a sequence that specifies the size of each dimension. For fixed-size dimensions of the dataset, the size of the chunk may not exceed the size of the dataset.</p>
</dd>
<dt><code>dcpl:get_chunk()</code></dt>
<dd><p>Returns the chunk size as a table with a sequence that specifies the size of each dimension.</p>
</dd>
<dt><code>dcpl:set_deflate(level)</code></dt>
<dd><p>Enables compression of the raw data using the <a href="http://www.zlib.net/feldspar.html">deflate algorithm</a> of zlib. The compression level is a number in the range <strong>0</strong> to <strong>9</strong>, where a higher level corresponds to a better compression ratio.</p>
</dd>
<dt><code>dcpl:set_fill_value(buf, buf_type)</code></dt>
<dd><p>Sets the fill value for a dataset. The fill value is read from the array <code>buf</code>, whose element type corresponds to the datatype <code>buf_type</code>. The datatype of the buffer must be <a href="http://www.hdfgroup.org/HDF5/doc/UG/11_Datatypes.html#Dtransfer">convertible</a> to the datatype of the dataset.</p>
<p>The fill value may be set to be undefined by passing <strong>nil</strong> as <code>buf</code>. In this case, the argument <code>buf_type</code> may be omitted.</p>
</dd>
<dt><code>dcpl:get_fill_value(buf, buf_type)</code></dt>
<dd><p>Retrieves the fill value for a dataset. The fill value is written to the array <code>buf</code>, whose element type corresponds to the datatype <code>buf_type</code>. The datatype of the buffer must be <a href="http://www.hdfgroup.org/HDF5/doc/UG/11_Datatypes.html#Dtransfer">convertible</a> from the datatype of the dataset.</p>
</dd>
<dt><code>dcpl:fill_value_defined()</code></dt>
<dd><p>Determines whether a fill value has been defined.</p>
<p>The function returns one of the following:</p>
<ul>
<li><strong>&quot;undefined&quot;</strong>: the fill value is undefined;</li>
<li><strong>&quot;default&quot;</strong>: the fill value has been set by the library;</li>
<li><strong>&quot;user_defined&quot;</strong>: the fill value has been set by the program.</li>
</ul>
</dd>
</dl>
<h3 id="dataset-transfer-properties">Dataset transfer properties</h3>
<p><em>The following methods are available if HDF5 is compiled with MPI-IO support.</em></p>
<dl>
<dt><code>dxpl:set_dxpl_mpio(xfer_mode)</code></dt>
<dd><p>Set <a href="http://www.hdfgroup.org/HDF5/PHDF5/parallelhdf5hints.pdf">MPI-IO data transfer</a> mode, which can be any of the following:</p>
<ul>
<li><strong>&quot;independent&quot;</strong>: each process does independent I/O (the default);</li>
<li><strong>&quot;collective&quot;</strong>: all processes participate in collective I/O.</li>
</ul>
</dd>
<dt><code>dxpl:get_dxpl_mpio()</code></dt>
<dd><p>Returns MPI-IO data transfer mode.</p>
</dd>
</dl>
<h3 id="link-creation-properties">Link creation properties</h3>
<dl>
<dt><code>lcpl:set_create_intermediate_group(flag)</code></dt>
<dd><p>Sets the property specifying whether missing intermediate groups are to be created. If <code>flag</code> is <strong>true</strong>, a function creating an object in a group different from the current group will create missing intermediate groups (the default). If <code>flag</code> is <strong>false</strong>, a function creating an object in a group different from the current group will raise an error if intermediate groups are missing.</p>
</dd>
<dt><code>lcpl:get_create_intermediate_group()</code></dt>
<dd><p>Returns <strong>true</strong> if missing intermediate groups are to be created, otherwise returns <strong>false</strong>.</p>
</dd>
</dl>
</div>
<div class="footer">
&copy; Copyright 2013–2014, Peter Colberg.
Created using <a href="http://johnmacfarlane.net/pandoc/">Pandoc</a>.
</div>
</body>
</html>
